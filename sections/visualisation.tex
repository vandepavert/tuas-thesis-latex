\documentclass[../main.tex]{subfiles}
\DoIfAndOnlyIfStandAlone{%
    \externaldocument{linear-block-codes}%
    \setcounter{chapter}{3}%
}%

\begin{document}

    \chapter{Visualisation}

    We consider two kinds of errors: random errors, which are distributed randomly among individual bits; and burst errors, which occur in consecutive groups of hundreds of bits. Burst errors are usually the result of, for example, fingerprints, dust and scratches on the disc surface \autocite{wicker1999reed}.


    Additionally to the BSC as described in \Cref{sec:maximum-likelihood-decoding} we should mention the Binary Erasure Channel (BEC), in case a codeword is transmitted, but nothing is received \autocite{mackay2003information}. Let $c$ be the transmitted code with alphabet $\{0,1\}$, let $r$ be the received code with alphabet $\{0,1,e\}$ where $e$ denotes the erasure. This channel is characterised by the following conditional probabilities:

    \begin{align*}
        P(r=0 | c=0) &= 1-p\\
        P(r=e | c=0) &= p\\
        P(r=1 | c=0) &= 0\\
        P(r=0 | c=1) &= 0\\
        P(r=e | c=1) &= p\\
        P(r=1 | c=1) &= 1-p
    \end{align*}

    \begin{figure}[htp]
        \begin{center}
            \begin{tikzpicture}[
                            > = latex,
                node distance = 4em and 15em,
                   bit/.style = {rectangle, draw=black, thick, minimum size=7mm}
                ]
                % nodes
                \node[bit]    (topleft)                                                 {0};
                \node[bit]    (topright)      [right=of topleft]                        {0};
                \node[bit]    (bottomleft)    [below=of topleft]                        {1};
                \node[bit]    (bottomright)   [right=of bottomleft]                     {1};
                \node[bit]    (erasure)       at \findmid{0.5}{topright}{bottomright}   {$e$};

                % labels
                \node[left=1cm]  at \findmid{0.5}{topleft}{bottomleft}   {$c$};
                \node[right=1cm] at \findmid{0.5}{topright}{bottomright} {$r$};


                % lines
                \draw[->,line width=1pt] (topleft.east) -- (topright.west) node[midway, above] {$1-p$};
                \draw[->,line width=1pt] (topleft.east) -- (erasure) node[pos=0.9, above] {$p$};

                \draw[->,line width=1pt] (bottomleft.east) -- (bottomright.west) node[midway, below] {$1-p$};
                \draw[->,line width=1pt] (bottomleft.east) -- (erasure)  node[pos=0.9, below] {$p$};
            \end{tikzpicture}
        \end{center}
        \caption{Model of the binary erasure channel (BEC)}
        \label{fig:binary_erasure_channel}
    \end{figure}

    Cross-interleaved Reed-Solomon code (CIRC) is well suited to deal with combinations of random as well as burst errors. For example, CIRC is used in compact discs with requirements such as:

    \begin{itemize}
        \item low redundancy;
        \item the ability to correct random errors and burst errors;
        \item good possibility of error concealment in case the correction capacity is surpassed.
    \end{itemize}


    \section{Bit Stream Encoding}
    An analog-to-digital converter (ADC) converts sound into a digital data stream at a sample rate of 44.1 kHz, which, according to Nyquist's sampling theorem, is sufficient to reproduce a maximum audio frequency of 20 kHz. The 32-bit stereo sample has 16 bits for the left and 16 bits for the right channel. Six of these samples are then grouped in a frame of 32 audio bits, 16-bit per audio channel. The net audio bit stream is therefore $44100 \times 32=1.41 Mbits/s$. These samples are then each divided to form 24 8-bit symbols per frame. \Cref{fig:bit_streams} shows this as bit stream $B_1$. In $B_2$, 8 parity symbols and a control and display symbol (C \& D) are added such that each frame now contains 33 data symbols. The C \& D symbol contains information for the listener which can be shown if the player has a display. Subsequently an eight-to-fourteen (EFM) code is used to translate these into 14-bit symbols plus three merging bits in $B_3$. This brings the net data bit stream rate to $1.94 Mbits/s$. Then a synchronisation pattern of 27 bits is added to the frame to obtain bit stream Bi of $33 \times 17+27=588$ channel bits per frame in such a way that each 1 indicates a pit edge; it therefore makes no difference if pit and land were interchanged on a disc. The total bit rate after all these data manipulations is approximately $4.32 Mbits/s$ \autocite{wicker1999reed}.

\iffalse
    \newpage

    Test page for figures. Remove before publishing
    %----------------------------------------------

    \begin{figure}[h!tp]
        \centering
        \begin{bytefield}{32}
            \begin{rightwordgroup}{\scriptsize 1 frame}
                \wordbox{1}{}
            \end{rightwordgroup} \\
            \begin{rightwordgroup}{\scriptsize 32 bits per sampling period}
                \bitbox{8}{1011001}
                \bitbox{8}{01110010}
                \bitbox{8}{1000111}
                \bitbox{8}{01010010}
            \end{rightwordgroup} \\
            \begin{rightwordgroup}{\scriptsize 4 symbols of 8 bits}
                \bitbox{8}{8 bits}
                \bitbox{8}{8 more bits}
                \bitbox{8}{8 more bits}
                \bitbox{8}{8 more bits}
            \end{rightwordgroup} \\
            \wordbox{2}{A 32-bit field. Note that text wraps within the box.}\\
            \begin{rightwordgroup}{\scriptsize 4 symbols of 8 bits}
                \bitbox{1}{1}  \bitbox{1}{0}  \bitbox{1}{1}  \bitbox{1}{1}
                \bitbox{1}{1}  \bitbox{1}{0}  \bitbox{1}{0}  \bitbox{1}{1}
                \bitboxes{1}{01000010}
                \bitboxes*{1}{01000010}
                \bitboxes*{1}{01000010}
            \end{rightwordgroup} \\
        \end{bytefield}
    \end{figure}

    %----------------------------------------------

    \begin{figure}[h!tp]
        \centering
        \begin{tikzpicture}[
                        > = latex,
               bit/.style = {rectangle, draw=black, thin, minimum size=2.5mm},
            sample/.style = {rectangle, draw=black, thin, minimum size=2.5mm, inner xsep=1em, outer xsep=0pt},
            symbol/.style = {},
              grey/.style = {fill=gray!25},
            wordbox/.code = {\\\wordbox{1}{Field: #1}},
             bitbox/.code = {\\\bitbox{1}{#1}},
            ]
            \node {
                \begin{bytefield}{8}
                    \wordbox{1}{Source: A}
                    \tikzset{wordbox/.list={1,2,3}}
 %                   \tikzset{bitbox/.list={0,1,2,3,4,5,6,7}}
                \end{bytefield}
            };
        \end{tikzpicture}
    \end{figure}

    %----------------------------------------------

    \begin{figure}[h!tp]
        \centering
        \begin{tikzpicture}[
                        > = latex,
               bit/.style = {rectangle, draw=black, thin, minimum size=2.5mm},
            sample/.style = {rectangle,
                            draw=black,
                            thin,
                            minimum size=2.5mm,
                            inner sep=0pt,
                            outer sep=0pt},
            symbol/.style = {},
              grey/.style = {fill=gray!25},
            wordbox/.code = {\\\wordbox{1}{Field: #1}},
             bitbox/.code = {\\\bitbox{1}{#1}},
            ]

            \foreach \x in {0,...,7}{%
                \node[bit] at (\x/2.51,0) {$\x$};
            }
        \end{tikzpicture}
    \end{figure}

    %----------------------------------------------

    \begin{figure}[h!tp]
        \centering
        \begin{tikzpicture}[scale=0.75]
            \draw (0,10)-- (15,10);
            \foreach \x in {0,...,4}{
                \draw[draw=green] (3*\x,10)--++(0,-0.2) node[above=2.5mm]{\x};
                \foreach \y [evaluate=\y as \j using int(\x+\y)]in {1,...,4}
                    \draw[draw=blue] ({3*(\x+\y/5)},10)--++(0,-0.2)
                    node[below=2.5mm]{\j}
                    node[below=6mm]{\y};
            }
            \draw[draw=red] (3*5,10)--++(0,-0.2);
        \end{tikzpicture}
    \end{figure}

    %----------------------------------------------

    \newcommand{\bitlabel}[2]{%
        \bitbox[]{#1}{%
            \raisebox{0pt}[4ex][0pt]{%
                \turnbox{45}{\fontsize{7}{7}\selectfont#2}%
            }%
        }%
    }
    \vspace{10ex}
    \begin{figure}[h!tp]
        \centering
        \begin{bytefield}[bitwidth=1em]{16}
            \bitlabel{1}{Carry} & \bitlabel{1}{Reserved} &
            \bitlabel{1}{Parity} & \bitlabel{1}{Reserved} &
            \bitlabel{1}{Adjust} & \bitlabel{1}{Reserved} &
            \bitlabel{1}{Zero} & \bitlabel{1}{Sign} &
            \bitlabel{1}{Trap} & \bitlabel{1}{Interrupt enable} &
            \bitlabel{1}{Direction} & \bitlabel{1}{Overflow} &
            \bitlabel{2}{I/O privilege level (12--13)} &
            \bitlabel{1}{Nested task} & \bitlabel{1}{Reserved} \\
            \bitheader{0-15} \\
            \bitboxes{1}{0100000101000000}\\
            \bitboxes*{1}{0100000101000000}\\
            \bitbox{1}{0} & \bitbox{1}[bgcolor=gray!50]{1} & \bitbox{1}{0} & \bitbox{1}{0} &
            \bitbox{1}{0} & \bitbox{1}{0} & \bitbox{1}{0} & \bitbox{1}{1} &
            \bitbox{1}{0} & \bitbox{1}{1} & \bitbox{1}{0} & \bitbox{1}{0} &
            \bitbox{1}{0} & \bitbox{1}{0} & \bitbox{1}{0} & \bitbox{1}{0}
        \end{bytefield}
    \end{figure}

    %----------------------------------------------

    \newpage
\fi


    % commands with parameters
    %----------------------------------------------
    % 4 boxes with 8 bits
    \newcommand{\bits}[4]{%
        \begin{bytefield}[
                bitformatting={},
                bitheight=9pt,
                bitwidth=0.0125\linewidth
            ]{32}%
            \bitbox{8}{\tiny#1}
            \bitbox{8}{\tiny#2}
            \bitbox{8}{\tiny#3}
            \bitbox{8}{\tiny#4}
        \end{bytefield}%
    }%

    % 2 boxes with 8 bits, #1 8 or 14 bits, #2 first byte, #3 second byte
    \newcommand{\efm}[3][8]{%
        \begin{bytefield}[
                bitformatting={\tiny\centering\itshape},
                bitheight=9pt,
                bitwidth=0.0175\linewidth*8/#1
            ]{2*#1}
            \bitbox{#1}{\tiny$#2$}
            \bitbox{1}{}
            \bitbox{#1}{\tiny$#3$}
            \bitbox{1}{}
        \end{bytefield}%
    }%

    % frame wordbox with bitbox width of #1
    \newcommand{\sframe}[2][8]{%
        \begin{bytefield}[
                bitformatting={\tiny\centering\itshape},
                bitheight=9pt,
                bitwidth=0.0125\linewidth,
            ]{#2*#1}
%            \wordbox{1}{}
            \wordbox{1}{\tiny 1 frame} % debugging: remove this line
        \end{bytefield}%
    }%

    % #2 periods of bitboxes with optional size #1 (default: 8)
    \newcommand{\periods}[2][8]{%
        \begin{bytefield}[
                bitformatting={\tiny\centering\itshape},
                bitheight=9pt,
                bitwidth=0.0125\linewidth,
            ]{#2*#1}
            \foreach \x in {1,...,#2} {%
%                \bitbox{#1}{}
               \bitbox{#1}{\tiny\x} % debugging: remove this line
            }
        \end{bytefield}%
    }%

    % #2 data symbols on a #3 symbol space of bitboxes with optional size #1 (default: 8)
    % and an array #4 telling which bytes to colour
    \newcommand{\symbols}[4][8]{%
        \begin{bytefield}[
                bitformatting={\tiny\centering\itshape},
                bitheight=9pt,
                bitwidth=0.0125\linewidth*#3/#2,
            ]{#2*#1}
            \foreach \x in {1,...,#2} {%
%                \bitbox{#1}{}
                \ifnum\x=#4
                    \bitbox{#1}[bgcolor=gray!50]{\tiny\x} % debugging: remove this line
                \else
                    \bitbox{#1}{}
                \fi
            }
        \end{bytefield}%
    }%


    % The figure
    % for debugging: every node is filled grey to see their proper box size
    %----------------------------------------------
    \begin{figure}[h!tp]
        \centering
        \begin{tikzpicture}[
            every node/.append style = {thin, minimum size=2.5mm,inner sep=0mm,fill=gray!15},
                        > = latex,
               bit/.style = {rectangle, draw=black},
            sample/.style = {},
            symbol/.style = {},
             frame/.style = {draw=none},
               dot/.style = {circle, draw, fill, minimum size=1mm, inner sep=0mm, node contents={}},
            ]
            % NODES & COORDINATES
            %----------------------------------------------

            % set 1 frame
            \node(frame) [frame] {\sframe{6}}; % fixme: remove wordbox and draw[<->] from west to east
            \coordinate(frame0) at (frame.west);


            % draw 1 frame and 6 sampling periods
            \node(samples) [sample,below=5mm of frame] {\periods{6}};

            % using calc library to define a coordinate
            \coordinate(period2) at ($(samples.south west)!0.5!(samples.south)$);

            % 32 bits per sampling period
            \node(period)
                [symbol, below=5mm of period2, label=right:{\tiny32 bits per sampling period}]
                {\bits{10111001}{01110010}{10001111}{01010010}};

            % 4 symbols of 8 bits
            \node(symbols)
                [symbol, below=3mm of period, label=right:{\tiny4 symbols of 8 bits}]
                {\periods[8]{4}};

            % 24 audio symbols
            \node(audio) [sample,below=2cm of samples] {\symbols[2]{24}{24}{15}};

            % using calc library to define coordinates
            \coordinate(audio5) at ($(audio.north west)!0.333!(audio.north)$);
            \coordinate(audio8) at ($(audio.north west)!0.667!(audio.north)$);

            % 33 data symbols
            \node(data) [sample,below=1cm of audio] {\symbols[2]{33}{24}{33}};

            % EFM
            \node(efm8) [sample,below=5mm of data] {\efm[8]{01100001}{01000111}};
            \node(efm14) [sample,below=3mm of efm8] {\efm[14]{10000100100010}{00100100100100}};


            % 588 channel bits
            \node(channel) [sample,below=2cm of data] {\symbols[2]{33}{24}{1}};


            % CONNECTIONS
            %----------------------------------------------

            % frame to samples
            \draw[dashed] (frame.south west) -- (samples.north west);
            \draw[dashed] (frame.south east) -- (samples.north east);

            % periods to one sampling
            \draw[name path=line1]
                            \findmid{0.333}{samples.south west}{samples.south} --
                            (period.north west);                                            % name this line 1
            \draw[]         \findmid{0.667}{samples.south west}{samples.south} --
                            (period.north east);

            % sampling period bits to symbols
            \draw[dashed]   (period.south west) -- (symbols.north west);
            \draw[dashed]   \findmid{0.5}{period.south west}{period.south} --
                            \findmid{0.5}{symbols.north west}{symbols.north} ;
            \draw[dashed]   (period.south) -- (symbols.north);
            \draw[dashed]   \findmid{0.5}{period.south east}{period.south} --
                            \findmid{0.5}{symbols.north east}{symbols.north} ;
            \draw[dashed]   (period.south east) -- (symbols.north east);

            % sampling period bits to audio symbols
            \draw[dashed]   (symbols.south west) -- (audio5.north) [name path=line2];       % name this line 2
            \draw[dashed]   (symbols.south east) -- (audio8.north);

            % samples to audio symbols
            \draw[draw=none](samples.south west) -- (audio.north west) [name path=line3];   % name this invisible line 3
            \path[name intersections={of=line1 and line3,by=a}];                            % find intersection a
            \draw[dashed]   (samples.south west) -- (a);                                    % draw line to intersection b
            \path[name intersections={of=line2 and line3,by=b}];                            % find intersection b
            \draw[dashed]   (b) -- (audio.north west);                                      % draw line from intersection b
            \draw[dashed]   (samples.south east) -- (audio.north east);

            % audio symbols to data symbols
            \draw[dashed]   (audio.south west) -- (data.north west);
            \draw[dashed]   (audio.south east) -- (data.north east);


            % LEFT SIDE TEXT
            %----------------------------------------------

            % RIGHT SIDE TEXT
            %----------------------------------------------


        \end{tikzpicture}
        \caption{Bit streams in the encoding process}
        \label{fig:bit_streams}
    \end{figure}
    %----------------------------------------------
    \newpage


    \section{Cross-interleaved Reed-Solomon Code (CIRC)}

    Cross-interleaving separates the symbols in a codeword, as codewords undergo a second encoding on a symbol basis. It becomes less likely that a burst from the outer decoder disturbs more than one Reed-Solomon symbol in any one codeword in the inner code.

    Since the information in CIRC is interleaved in time, errors that occur at the input of the error correction system are spread over a large number of frames during decoding. The error correction system can correct a burst of thousands of data bits because the errors are spread out by interleaving. If more than the permitted amount of errors occur, they can only be detected.

    The audio signal degrades gracefully by applying interpolation or muting the output signal. Key parameters to the success of concealment of errors are thoughtful positioning of the left and right audio channels as well as placing audio samples on even- and odd-numbered instants within the interleaving scheme. There are several interleaved structures used in the CD which allow for error detection and correction with a minimum of redundancy.

    A simple interleaving method is block interleaving. In block interleaving, a block of data symbols is written row by row as a $n \times m$ matrix and read column by column. It is obvious that the interleaver requires a memory capacity of $n \times m$ symbols. The CD uses a more effective interleaver, a periodic or convolutional interleaver, known as a cross-interleaver. Before transmission the symbols of the codewords are multiplexed over delay lines with differing delays, combined (demultiplexed) and send to the channel. At the receiver this process is reversed. In \Cref{fig:circ_encoder} two Reed-Solomon codes, $C_1$ and $C_2$, are interleaved cross-wise. Outer code $C_1$ is RS(32,28) and inner code $C_2$ is RS(28,24). The symbols are 8 bits long and are elements of $GF(2^8)$. The code rate is

    \begin{equation*}
        \frac{k_1}{n_1} \times \frac{k_2}{n_2} = \frac{3}{4}
    \end{equation*}

    \noindent
    and for both codes the minimum distance is 5 which allows for a correction of maximum two errors in one code or four erasures. Each information frame contains 6 right and 6 left channel audio samples, denoted by $R$ and $L$. Each 16-bit sample is divided into two 8-bit symbols or bytes (W) and the even- and odd-numbered audio samples are subjected to a delay of two bytes (2D). The 24 bytes are regrouped and the even- and odd-numbered samples are further separated by the parity bytes of code $C_2$ (Q). These 28 bytes are multiplexed and subjected to 28 different delays (1D to 27D) analogous to the convolutional interleaver as mentioned above. As a result of the convolutional interleave, one $C_2$ code is stored in 28 different blocks spread over 109 blocks. The required memory for a delay operator $D=4$ is computed as $4 \times 27 \times 28/2 = 1502$ bytes. Encoder $C_1$ forms four parity bytes (P) after which a delay of 1 byte is inserted every other line in order to separate two adjacent symbol errors which are a result of small burst errors. Parity bytes P are inverted to prevent all zero codewords. This is important for detection of bit insertions or deletions \autocite{wicker1999reed}.

    \newpage
    %----------------------------------------------
    \begin{figure}[h!tp]
        \centering
        [Placeholder]
        \caption{Block Diagram of a CIRC encoder by K.A. Schouhamer Immink cited in \autocite{wicker1999reed}}
        \label{fig:circ_encoder}
    \end{figure}
    %----------------------------------------------
    \newpage


    \section{Decoding}

    While the encoder has been standardised in the Red Book audio specifications, the decoder strategy has not been standardised. Each manufacturer is, therefore, free to choose their own decoding strategy. Analogous to the encoding process, the error correction system consists of two decoders $D_1$ and $D_2$ . In most strategies, decoder $D_1$ corrects one error. If more than one error may occur in the 32 bits from the demodulator, $D_1$ attaches an erasure flag to the 28 outgoing symbols. Erasures will be spread over a number of codewords at the input of $D_2$. Decoder $D_2$ can at most correct four erasures. If more than four erasures may occur $D_2$ attaches an erasure flag to the 24 outgoing symbols. These flags allow the concealment system to react to the unreliable signal. The maximum fully correctable burst length and the maximum interpolation length are determined by the CIRC format. Four blocks are correctable, since code $C_2$ is quadruple-erasure-correcting and the maximum fully correctable burst error is about 4000 data bits. This corresponds to a track length of 2.5 mm on a CD, where an effective length on track of data bits of about 0.6 µm. About 50 blocks, roughly 12000 bits, can be concealed by interpolation. This corresponds to close to 7.5 mm of track length. Given the standardised format of the CD, a designer of a decoding integrated circuit (IC) can choose a certain decoding strategy \autocite{wicker1999reed}.

    One way of decoding these codes depend on simultaneously solving a linear system of equations (LSE). The Berlekamp-Massey algorithm is a way of solving an LSE, but the inner working of this mechanism is not in the scope of this thesis.

\end{document}
